# 进程和线程
## 多进程
### os模块中的fork方式实现多线程
- fork方式调用一次，返回两次
- 操作系统将父进程复制出一份子进程
- 子进程永远返回0，父进程中返回的子进程的ID
- 案例v01
- 案例v02
- 案例v03
### 进程间通信
- Queue：用来在多个进程间实现通信
    - Put：插入数据到队列中
        - blocked
        - timeout
            - 如果blocked为True。并且timeout为正值，会阻塞timeout指定的时间，知道队列右剩余的空间。如果超时，抛出Queue.Full异常。
            - 如果blocked为False，且Queue已满，立刻抛出Queue.Full异常。
    - Get: 从队列读取并且删除一个元素
        - blocked
        - timeout
        - 同Put，抛出Queue.Empty异常
- Pipe: 常用来在两个进程间通信
- Value+Array
- 案例v04
### Pipe通信机制
- 用来子在两个进程进行通信，两个进程分别位于管道两端
- 返回（conn1, conn2）代表一个管道的两个端
- 参数
    - duplex
        - True：全双工模式, conn1 和 conn2均可收发
        - False: conn1只负责接收信息，conn2只负责发送信息
    - send：发送信息
    - recv：接收信息
- 案例v05

## 多线程
- 类似于同时执行多个不同程序
- 用threading模块创建多线程
    - 案例v06
    - 案例v07(案例v06重写)
    
### 线程同步
- 保证数据的正确性，需要对多个线程进行同步
- Lock
- RLock
- 案例v08

## 协程
- 又称微线程，纤程，是一种用户级别的轻量级线程。拥有自己的寄存器上下文和栈，协程能够保存上一次调用时的状态
- yield支持
- 第三方库gevent提供了比较完善的协程支持
    - 基于libev的快速事件循环，Linux上是epoll机制
    - 基于greenlet的轻量级执行单元
    - API复用了Python标准库里的内容
    - 支持SSL的协作式sockets
    - 可通过线程池或c-ares实现DNS查询
    - 通过monkey patching功能使得第三方模块变成协作式
- 案例v09
- 案例v10(案例v09改写)

## 分布式进程
- 将Process进程分不到多台机器上，充分利用多台机器的性能完成复杂的任务。（本地队列网络化）
- 创建服务进程
    - 步骤
        - 1.建立队列Queue，用来进行进程间的通信。服务进程创建任务队列task_queue, 用来作为传递任务给任务进程的通道；
        服务进程创建结果队列result_queue, 作为任务进程完成任务后回复服务进程的通道。在分布式多进程环境下，必须通过
        Queuemanager获得的Queue接口来添加任务
        - 2.把第一步中建立的队列在网络上注册，暴露给其他进程（主机），注册后获得网络队列，相当于本地队列的映像
        - 3.建立一个对象(Queuemanager(BaseManager))实例manager，绑定端口和验证口令
        - 4.启动第三步中建立的实例，即启动管理manager，监管信息通道
        - 5.通过管理实例的方法获得通过网络访问的Queue对象，即再把网络队列实体化成可以使用的本地队列
        - 6. 创建任务到'本地'队列中，自动上传任务到网络队列中，分配给任务进程进行处理
    - 案例v11（Linux版本）
    - 案例v12（Windows版本）
- 创建任务进程
    - 步骤
        - 1. 使用QueueManager注册用于获取Queue的方法名称，任务进程只能通过名称来在网络上获取Queue
        - 2. 连接服务器，端口和验证口令注意保持与服务进程完全一致
        - 3. 从网络上获取Queue，进行本地化
        - 4. 从task队列获取任务，并把结果写入result队列
    - 案例v13
    
# 网络编程
